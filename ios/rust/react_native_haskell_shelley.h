#ifndef _REACT_NATIVE_HASKELL_SHELLEY_
#define _REACT_NATIVE_HASKELL_SHELLEY_

/* Generated with cbindgen:0.14.1 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef const char *CharPtr;

typedef struct {
  void *_0;
} RPtr;

typedef struct {
  const uint8_t *ptr;
  uintptr_t len;
} DataPtr;

bool address_from_bech32(CharPtr chars, RPtr *result, CharPtr *error);

bool address_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool address_network_id(RPtr rptr, uint8_t *result, CharPtr *error);

bool address_to_bech32(RPtr rptr, CharPtr *result, CharPtr *error);

bool address_to_bech32_with_prefix(RPtr rptr, CharPtr prefix, CharPtr *result, CharPtr *error);

bool address_to_bytes(RPtr address, DataPtr *result, CharPtr *error);

bool asset_name_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool asset_name_name(RPtr asset_name, DataPtr *result, CharPtr *error);

bool asset_name_new(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool asset_name_to_bytes(RPtr asset_name, DataPtr *result, CharPtr *error);

bool asset_names_add(RPtr *asset_names, RPtr item, CharPtr *error);

bool asset_names_get(RPtr asset_names, uintptr_t index, RPtr *result, CharPtr *error);

bool asset_names_len(RPtr asset_names, uintptr_t *result, CharPtr *error);

bool asset_names_new(RPtr *result, CharPtr *error);

bool assets_get(RPtr assets, RPtr key, RPtr *result, CharPtr *error);

bool assets_insert(RPtr assets, RPtr key, RPtr value, RPtr *result, CharPtr *error);

bool assets_keys(RPtr assets, RPtr *result, CharPtr *error);

bool assets_len(RPtr assets, uintptr_t *result, CharPtr *error);

bool assets_new(RPtr *result, CharPtr *error);

bool base_address_from_address(RPtr rptr, RPtr *result, CharPtr *error);

bool base_address_new(uint8_t network, RPtr payment, RPtr stake, RPtr *result, CharPtr *error);

bool base_address_payment_cred(RPtr base_address, RPtr *result, CharPtr *error);

bool base_address_stake_cred(RPtr base_address, RPtr *result, CharPtr *error);

bool base_address_to_address(RPtr base_address, RPtr *result, CharPtr *error);

bool big_num_checked_add(RPtr big_num, RPtr other, RPtr *result, CharPtr *error);

bool big_num_checked_sub(RPtr big_num, RPtr other, RPtr *result, CharPtr *error);

bool big_num_clamped_sub(RPtr big_num, RPtr other, RPtr *result, CharPtr *error);

bool big_num_compare(RPtr big_num, RPtr rhs, int8_t *result, CharPtr *error);

bool big_num_from_str(CharPtr chars, RPtr *result, CharPtr *error);

bool big_num_to_str(RPtr big_num, CharPtr *result, CharPtr *error);

bool bip32_public_key_as_bytes(RPtr bip32_public_key, DataPtr *result, CharPtr *error);

bool bip32_public_key_chaincode(RPtr bip32_public_key, DataPtr *result, CharPtr *error);

bool bip32_public_key_derive(RPtr bip32_public_key, int64_t index, RPtr *result, CharPtr *error);

bool bip32_public_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool bip32_public_key_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool bip32_public_key_to_bech32(RPtr bip32_public_key, CharPtr *result, CharPtr *error);

bool bip32_public_key_to_raw_key(RPtr bip32_public_key, RPtr *result, CharPtr *error);

bool bip_32_private_key_as_bytes(RPtr bip_32_private_key, DataPtr *result, CharPtr *error);

bool bip_32_private_key_derive(RPtr bip_32_private_key,
                               int64_t index,
                               RPtr *result,
                               CharPtr *error);

bool bip_32_private_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool bip_32_private_key_from_bip39_entropy(const uint8_t *entropy_data,
                                           uintptr_t entropy_len,
                                           const uint8_t *password_data,
                                           uintptr_t password_len,
                                           RPtr *result,
                                           CharPtr *error);

bool bip_32_private_key_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool bip_32_private_key_generate_ed25519_bip32(RPtr *result, CharPtr *error);

bool bip_32_private_key_to_bech32(RPtr bip_32_private_key, CharPtr *result, CharPtr *error);

bool bip_32_private_key_to_public(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool bip_32_private_key_to_raw_key(RPtr bip_32_private_key, RPtr *result, CharPtr *error);

bool bip_32_public_key_to_raw_key(RPtr bip_32_public_key, RPtr *result, CharPtr *error);

bool bootstrap_witness_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool bootstrap_witness_new(RPtr vkey,
                           RPtr signature,
                           const uint8_t *chain_code,
                           uintptr_t chain_code_len,
                           const uint8_t *attributes,
                           uintptr_t attributes_len,
                           RPtr *result,
                           CharPtr *error);

bool bootstrap_witness_to_bytes(RPtr bootstrap_witness, DataPtr *result, CharPtr *error);

bool bootstrap_witnesses_add(RPtr *witnesses, RPtr item, CharPtr *error);

bool bootstrap_witnesses_len(RPtr witnesses, uintptr_t *result, CharPtr *error);

bool bootstrap_witnesses_new(RPtr *result, CharPtr *error);

bool byron_address_attributes(RPtr rptr, DataPtr *result, CharPtr *error);

bool byron_address_byron_protocol_magic(RPtr rptr, uint32_t *result, CharPtr *error);

bool byron_address_from_address(RPtr rptr, RPtr *result, CharPtr *error);

bool byron_address_from_base58(CharPtr chars, RPtr *result, CharPtr *error);

bool byron_address_from_icarus_key(RPtr bip_32_public_key,
                                   uint32_t network,
                                   RPtr *result,
                                   CharPtr *error);

bool byron_address_is_valid(CharPtr chars, bool *result, CharPtr *error);

bool byron_address_to_address(RPtr rptr, RPtr *result, CharPtr *error);

bool byron_address_to_base58(RPtr rptr, CharPtr *result, CharPtr *error);

bool certificate_as_stake_delegation(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_as_stake_deregistration(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_as_stake_registration(RPtr certificate, RPtr *result, CharPtr *error);

bool certificate_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool certificate_new_stake_delegation(RPtr stake_delegation_ptr, RPtr *result, CharPtr *error);

bool certificate_new_stake_deregistration(RPtr stake_dereg_ptr, RPtr *result, CharPtr *error);

bool certificate_new_stake_registration(RPtr stake_reg_ptr, RPtr *result, CharPtr *error);

bool certificate_to_bytes(RPtr certificate, DataPtr *result, CharPtr *error);

bool certificates_add(RPtr *certificates, RPtr item, CharPtr *error);

bool certificates_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool certificates_get(RPtr certificates, uintptr_t index, RPtr *result, CharPtr *error);

bool certificates_len(RPtr certificates, uintptr_t *result, CharPtr *error);

bool certificates_new(RPtr *result, CharPtr *error);

bool certificates_to_bytes(RPtr certificates, DataPtr *result, CharPtr *error);

void charptr_free(CharPtr *ptr);

void dataptr_free(DataPtr *data);

bool ed25519_key_hash_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool ed25519_key_hash_to_bytes(RPtr ed25519_key_hash, DataPtr *result, CharPtr *error);

bool ed25519_signature_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool ed25519_signature_to_bytes(RPtr ed25519_signature, DataPtr *result, CharPtr *error);

void init_haskell_shelley_library(void);

bool legacy_daedalus_private_key_from_bytes(const uint8_t *data,
                                            uintptr_t len,
                                            RPtr *result,
                                            CharPtr *error);

bool linear_fee_coefficient(RPtr rptr, RPtr *result, CharPtr *error);

bool linear_fee_constant(RPtr rptr, RPtr *result, CharPtr *error);

bool linear_fee_new(RPtr coefficient, RPtr constant, RPtr *result, CharPtr *error);

bool multi_asset_get(RPtr multi_asset, RPtr key, RPtr *result, CharPtr *error);

bool multi_asset_insert(RPtr multi_asset, RPtr key, RPtr value, RPtr *result, CharPtr *error);

bool multi_asset_keys(RPtr multi_asset, RPtr *result, CharPtr *error);

bool multi_asset_len(RPtr multi_asset, uintptr_t *result, CharPtr *error);

bool multi_asset_new(RPtr *result, CharPtr *error);

bool multi_asset_sub(RPtr multi_asset, RPtr other, RPtr *result, CharPtr *error);

bool private_key_as_bytes(RPtr key, DataPtr *result, CharPtr *error);

bool private_key_from_extended_bytes(const uint8_t *data,
                                     uintptr_t len,
                                     RPtr *result,
                                     CharPtr *error);

bool private_key_to_public(RPtr private_key, RPtr *result, CharPtr *error);

bool public_key_as_bytes(RPtr pub_key, DataPtr *result, CharPtr *error);

bool public_key_from_bech32(CharPtr bech32_str, RPtr *result, CharPtr *error);

bool public_key_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool public_key_hash(RPtr rptr, RPtr *result, CharPtr *error);

bool public_key_to_bech32(RPtr public_key, CharPtr *result, CharPtr *error);

bool reward_address_from_address(RPtr rptr, RPtr *result, CharPtr *error);

bool reward_address_new(uint8_t network, RPtr payment, RPtr *result, CharPtr *error);

bool reward_address_payment_cred(RPtr reward_address, RPtr *result, CharPtr *error);

bool reward_address_to_address(RPtr reward_address, RPtr *result, CharPtr *error);

bool reward_addresses_add(RPtr *reward_addresses, RPtr item, CharPtr *error);

bool reward_addresses_get(RPtr reward_addresses, uintptr_t index, RPtr *result, CharPtr *error);

bool reward_addresses_len(RPtr reward_addresses, uintptr_t *result, CharPtr *error);

bool reward_addresses_new(RPtr *result, CharPtr *error);

void rptr_free(RPtr *ptr);

RPtr rptr_from_usize(uintptr_t usz);

uintptr_t rptr_into_usize(RPtr ptr);

bool script_hash_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool script_hash_to_bytes(RPtr script_hash, DataPtr *result, CharPtr *error);

bool script_hashes_add(RPtr *script_hashes, RPtr item, CharPtr *error);

bool script_hashes_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool script_hashes_get(RPtr script_hashes, uintptr_t index, RPtr *result, CharPtr *error);

bool script_hashes_len(RPtr script_hashes, uintptr_t *result, CharPtr *error);

bool script_hashes_new(RPtr *result, CharPtr *error);

bool script_hashes_to_bytes(RPtr script_hashes, DataPtr *result, CharPtr *error);

bool stake_credential_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool stake_credential_from_keyhash(RPtr keyhash, RPtr *result, CharPtr *error);

bool stake_credential_from_scripthash(RPtr scripthash, RPtr *result, CharPtr *error);

bool stake_credential_to_bytes(RPtr stake_credential, DataPtr *result, CharPtr *error);

bool stake_credential_to_keyhash(RPtr stake_credential, RPtr *result, CharPtr *error);

bool stake_credential_to_kind(RPtr stake_credential, uint8_t *result, CharPtr *error);

bool stake_credential_to_scripthash(RPtr stake_credential, RPtr *result, CharPtr *error);

bool stake_delegation_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool stake_delegation_new(RPtr stake_cred_ptr, RPtr pool_keyhash_ptr, RPtr *result, CharPtr *error);

bool stake_delegation_pool_keyhash(RPtr stake_delegation, RPtr *result, CharPtr *error);

bool stake_delegation_stake_credential(RPtr stake_delegation, RPtr *result, CharPtr *error);

bool stake_delegation_to_bytes(RPtr stake_delegation, DataPtr *result, CharPtr *error);

bool stake_deregistration_from_bytes(const uint8_t *data,
                                     uintptr_t len,
                                     RPtr *result,
                                     CharPtr *error);

bool stake_deregistration_new(RPtr stake_cred_ptr, RPtr *result, CharPtr *error);

bool stake_deregistration_stake_credential(RPtr stake_deregistration, RPtr *result, CharPtr *error);

bool stake_deregistration_to_bytes(RPtr stake_deregistration, DataPtr *result, CharPtr *error);

bool stake_registration_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool stake_registration_new(RPtr stake_cred_ptr, RPtr *result, CharPtr *error);

bool stake_registration_stake_credential(RPtr stake_registration, RPtr *result, CharPtr *error);

bool stake_registration_to_bytes(RPtr stake_registration, DataPtr *result, CharPtr *error);

bool transaction_body(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_certs(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_fee(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_body_inputs(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_outputs(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_body_to_bytes(RPtr transaction_body, DataPtr *result, CharPtr *error);

bool transaction_body_ttl(RPtr rptr, uint32_t *result, CharPtr *error);

bool transaction_body_withdrawals(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_add_bootstrap_input(RPtr tx_builder,
                                             RPtr hash,
                                             RPtr input,
                                             RPtr amount,
                                             CharPtr *error);

bool transaction_builder_add_change_if_needed(RPtr rptr,
                                              RPtr address,
                                              bool *result,
                                              CharPtr *error);

bool transaction_builder_add_input(RPtr tx_builder,
                                   RPtr address,
                                   RPtr input,
                                   RPtr amount,
                                   CharPtr *error);

bool transaction_builder_add_key_input(RPtr tx_builder,
                                       RPtr hash,
                                       RPtr input,
                                       RPtr amount,
                                       CharPtr *error);

bool transaction_builder_add_output(RPtr tx_builder, RPtr output, CharPtr *error);

bool transaction_builder_add_script_input(RPtr tx_builder,
                                          RPtr hash,
                                          RPtr input,
                                          RPtr amount,
                                          CharPtr *error);

bool transaction_builder_build(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_fee_for_input(RPtr tx_builder,
                                       RPtr address,
                                       RPtr input,
                                       RPtr amount,
                                       RPtr *result,
                                       CharPtr *error);

bool transaction_builder_fee_for_output(RPtr rptr, RPtr output, RPtr *result, CharPtr *error);

bool transaction_builder_get_deposit(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_explicit_input(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_explicit_output(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_fee_if_set(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_get_implicit_input(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_min_fee(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_builder_new(RPtr linear_fee,
                             RPtr minimum_utxo_val,
                             RPtr pool_deposit,
                             RPtr key_deposit,
                             RPtr *result,
                             CharPtr *error);

bool transaction_builder_set_certs(RPtr tx_builder, RPtr certs, CharPtr *error);

bool transaction_builder_set_fee(RPtr tx_builder, RPtr fee, CharPtr *error);

bool transaction_builder_set_metadata(RPtr tx_builder, RPtr metadata, CharPtr *error);

bool transaction_builder_set_ttl(RPtr tx_builder, uint32_t ttl, CharPtr *error);

bool transaction_builder_set_validity_start_interval(RPtr tx_builder, uint32_t vst, CharPtr *error);

bool transaction_builder_set_withdrawals(RPtr tx_builder, RPtr withdrawals, CharPtr *error);

bool transaction_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_hash_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_hash_to_bytes(RPtr transaction_hash, DataPtr *result, CharPtr *error);

bool transaction_input_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool transaction_input_index(RPtr transaction_input, uint32_t *result, CharPtr *error);

bool transaction_input_new(RPtr transaction_id, uint32_t index, RPtr *result, CharPtr *error);

bool transaction_input_to_bytes(RPtr transaction_input, DataPtr *result, CharPtr *error);

bool transaction_input_transaction_id(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_inputs_add(RPtr *transaction_inputs, RPtr item, CharPtr *error);

bool transaction_inputs_get(RPtr tx_inputs, uintptr_t index, RPtr *result, CharPtr *error);

bool transaction_inputs_len(RPtr transaction_inputs, uintptr_t *result, CharPtr *error);

bool transaction_inputs_new(RPtr *result, CharPtr *error);

bool transaction_new(RPtr body, RPtr witness_set, RPtr *result, CharPtr *error);

bool transaction_new_with_metadata(RPtr body,
                                   RPtr witness_set,
                                   RPtr *metadata,
                                   RPtr *result,
                                   CharPtr *error);

bool transaction_output_address(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_output_amount(RPtr rptr, RPtr *result, CharPtr *error);

bool transaction_output_from_bytes(const uint8_t *data,
                                   uintptr_t len,
                                   RPtr *result,
                                   CharPtr *error);

bool transaction_output_new(RPtr address, RPtr amount, RPtr *result, CharPtr *error);

bool transaction_output_to_bytes(RPtr transaction_output, DataPtr *result, CharPtr *error);

bool transaction_outputs_get(RPtr tx_outputs, uintptr_t index, RPtr *result, CharPtr *error);

bool transaction_outputs_len(RPtr tx_outputs, uintptr_t *result, CharPtr *error);

bool transaction_to_bytes(RPtr transaction, DataPtr *result, CharPtr *error);

bool transaction_witness_set_new(RPtr *result, CharPtr *error);

bool transaction_witness_set_set_bootstraps(RPtr transaction_witness_set,
                                            RPtr bootstrap_witnesses,
                                            CharPtr *error);

bool transaction_witness_set_set_vkeys(RPtr transaction_witness_set,
                                       RPtr vkeywitnesses,
                                       CharPtr *error);

bool unit_interval_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool unit_interval_new(RPtr numerator, RPtr denominator, RPtr *result, CharPtr *error);

bool unit_interval_to_bytes(RPtr unit_interval, DataPtr *result, CharPtr *error);

bool utils_hash_transaction(RPtr tx_body, RPtr *result, CharPtr *error);

bool utils_make_daedalus_bootstrap_witness(RPtr tx_body_hash,
                                           RPtr addr,
                                           RPtr key,
                                           RPtr *result,
                                           CharPtr *error);

bool utils_make_icarus_bootstrap_witness(RPtr tx_body_hash,
                                         RPtr addr,
                                         RPtr key,
                                         RPtr *result,
                                         CharPtr *error);

bool utils_make_vkey_witness(RPtr tx_body_hash, RPtr sk, RPtr *result, CharPtr *error);

bool utils_min_ada_required(RPtr assets, RPtr min_utxo_val, RPtr *result, CharPtr *error);

bool value_checked_add(RPtr value, RPtr rhs, RPtr *result, CharPtr *error);

bool value_checked_sub(RPtr value, RPtr rhs, RPtr *result, CharPtr *error);

bool value_clamped_sub(RPtr value, RPtr rhs, RPtr *result, CharPtr *error);

bool value_coin(RPtr value, RPtr *result, CharPtr *error);

bool value_compare(RPtr value, RPtr rhs, int8_t *result, CharPtr *error);

bool value_multiasset(RPtr value, RPtr *result, CharPtr *error);

bool value_new(RPtr coin, RPtr *result, CharPtr *error);

bool value_set_coin(RPtr value, RPtr coin, CharPtr *error);

bool value_set_multiasset(RPtr value, RPtr multiasset, CharPtr *error);

bool vkey_new(RPtr pk, RPtr *result, CharPtr *error);

bool vkeywitness_from_bytes(const uint8_t *data, uintptr_t len, RPtr *result, CharPtr *error);

bool vkeywitness_new(RPtr vkey, RPtr signature, RPtr *result, CharPtr *error);

bool vkeywitness_signature(RPtr rptr, RPtr *result, CharPtr *error);

bool vkeywitness_to_bytes(RPtr vkeywitness, DataPtr *result, CharPtr *error);

bool vkeywitnesses_add(RPtr *witnesses, RPtr item, CharPtr *error);

bool vkeywitnesses_len(RPtr witnesses, uintptr_t *result, CharPtr *error);

bool vkeywitnesses_new(RPtr *result, CharPtr *error);

bool withdrawals_get(RPtr withdrawals, RPtr key, RPtr *result, CharPtr *error);

bool withdrawals_insert(RPtr withdrawals, RPtr key, RPtr value, RPtr *result, CharPtr *error);

bool withdrawals_keys(RPtr withdrawals, RPtr *result, CharPtr *error);

bool withdrawals_len(RPtr withdrawals, uintptr_t *result, CharPtr *error);

bool withdrawals_new(RPtr *result, CharPtr *error);

#endif /* _REACT_NATIVE_HASKELL_SHELLEY_ */
